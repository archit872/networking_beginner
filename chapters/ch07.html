<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <base href="../">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chapter 7 — Guided Project: Building & Debugging a Mini Network</title>
  <meta name="description" content="Apply core concepts by assembling a small network, running a local DNS and web server, and practicing a structured debugging workflow using developer tools.">
  <meta property="og:title" content="Chapter 7 — Guided Project: Building & Debugging a Mini Network">
  <meta property="og:description" content="Hands-on project: configure a router and hosts, run local DNS+web, break and fix connectivity using a repeatable workflow.">
  <meta property="og:type" content="article">
  <meta name="theme-color" content="#0b0f14">

  <link rel="stylesheet" href="styles/theme.css">
  <link rel="stylesheet" href="styles/layout-overrides.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Nav (verbatim across all pages). Only aria-current differs per page. -->
  <nav class="app-nav" aria-label="Primary">
    <div class="container inner">
      <div class="brand">Networking for Software Engineers</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="top-menu" aria-label="Toggle navigation">
        ☰ Menu
      </button>
      <div id="top-menu" class="menu" role="menubar">
        <a href="index.html" role="menuitem">Home</a>
        <a href="chapters/ch01.html" aria-current="page" role="menuitem">Chapters</a>
        <a href="chapters/appendix.html" role="menuitem">Appendix</a>
        <a href="chapters/glossary.html" role="menuitem">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Beginner</span>
        <span class="badge">Chapter 7</span>
        <span class="badge">Estimated time: 90–120 min</span>
      </div>
      <h1>Guided Project — Building &amp; Debugging a Mini Network</h1>
      <p class="abstract">
        It’s build time. You’ll assemble a small three-node network, configure addressing and a <strong><abbr title="Domain Name System">DNS</abbr></strong> resolver, run a local web server, and then intentionally “break” things to practice your debugging workflow. By the end, you’ll have a repeatable playbook for diagnosing issues in dev, lab, or cloud environments.
      </p>
    </div>
  </header>

  <main id="main" class="container section">
    <!-- Objectives -->
    <section class="card">
      <h2 id="objectives">Objectives</h2>
      <ul>
        <li>Set up a small network with distinct subnets and a <strong><abbr title="A router that forwards traffic between networks">gateway</abbr></strong>.</li>
        <li>Run a local DNS forwarder and an HTTP server and verify <strong><abbr title="Name-to-address mapping with caching">resolution</abbr></strong>, reachability, and <strong><abbr title="Hypertext Transfer Protocol over TLS">HTTPS</abbr></strong> behavior.</li>
        <li>Use a structured workflow to localize failures across <abbr title="Open Systems Interconnection">OSI</abbr> layers: Link → Network → Transport → Application.</li>
        <li>Document findings concisely so teammates can reproduce and learn.</li>
      </ul>
    </section>

    <!-- Topology -->
    <section class="section">
      <h2 id="topology">1) Topology &amp; Design</h2>
      <p>
        We’ll create a small <strong><abbr title="Local Area Network">LAN</abbr></strong> with three roles:
      </p>
      <ul>
        <li><strong>R1 (Router):</strong> Acts as default <abbr title="Next-hop router for off-subnet traffic">gateway</abbr>, runs a lightweight DNS forwarder (e.g., <em>dnsmasq</em>) and provides <abbr title="Dynamic Host Configuration Protocol">DHCP</abbr> or static leases.</li>
        <li><strong>H1 (Client):</strong> Developer workstation that will browse to a friendly hostname and run tests (ping, <abbr title="Trace hops across networks">traceroute</abbr>, <abbr title="Command-line HTTP client">curl</abbr>).</li>
        <li><strong>W1 (Web):</strong> Web server hosting a static page and JSON API; optional self-signed TLS for learning.</li>
      </ul>

      <figure>
        <img src="../assets/mini-network-topology.svg" alt="Three-node network diagram: Client H1 on 10.10.10.0/24, Router R1 with interfaces on 10.10.10.1 and 10.10.20.1, and Web W1 on 10.10.20.0/24. DNS forwarder on R1. Default routes from H1 and W1 to R1.">
        <figcaption>
          Topology: two subnets (<code>10.10.10.0/24</code> and <code>10.10.20.0/24</code>) with R1 routing between them. H1 and W1 use R1 as their default gateway. R1 forwards DNS queries upstream.
        </figcaption>
      </figure>

      <div class="callout info">
        <strong>Analogy:</strong> Think of R1 as your office’s receptionist: everyone on each floor (subnet) hands mail to the receptionist (gateway) to reach other floors or the outside world.
      </div>

      <h3 id="address-plan">Address Plan</h3>
      <pre data-lang="plan"><code>
R1:
  lan0: 10.10.10.1/24    (to H1 subnet)
  lan1: 10.10.20.1/24    (to W1 subnet)
H1: 10.10.10.100/24,  gw 10.10.10.1,  dns 10.10.10.1
W1: 10.10.20.100/24,  gw 10.10.20.1,  dns 10.10.10.1
Upstream DNS (example): 1.1.1.1, 8.8.8.8
Hostnames: web.local → 10.10.20.100
      </code></pre>

      <div class="callout warn">
        <strong>Trade-off:</strong> Static addressing simplifies demos and debuggability; <abbr title="Dynamic Host Configuration Protocol">DHCP</abbr> eases operations but can hide drift when leases change. For teaching, prefer static; for production, consider DHCP reservations plus strict documentation.
      </div>
    </section>

    <!-- Setup Options -->
    <section class="section">
      <h2 id="setup">2) Setup Paths (Choose One)</h2>
      <div class="grid two">
        <div class="card">
          <h3>Path A — Physical/Virtual NICs</h3>
          <ol>
            <li>Create two <abbr title="Virtual network interfaces implemented in software">virtual NICs</abbr> or use two real VLANs.</li>
            <li>Configure R1 with IP forwarding and static routes between interfaces.</li>
            <li>Assign H1 and W1 to their subnets; set default gateways.</li>
          </ol>
          <p><em>Pros:</em> Realistic, visibility into <abbr title="Address Resolution Protocol">ARP</abbr>/ICMP. <em>Cons:</em> Requires admin access and multiple NICs/VLANs.</p>
        </div>
        <div class="card">
          <h3>Path B — Docker Sandbox (Recommended)</h3>
          <ol>
            <li>Use a Docker <strong><abbr title="A host-local virtual network with NAT">bridge</abbr></strong> for each subnet.</li>
            <li>Attach lightweight containers as H1 and W1; run an R1 container with <abbr title="IP forwarding: kernel facility to route packets">forwarding</abbr> enabled and two attached networks.</li>
            <li>Run <em>dnsmasq</em> inside R1; run <em>nginx</em> or a tiny app server in W1.</li>
          </ol>
          <p><em>Pros:</em> Fast, reproducible, cross-platform. <em>Cons:</em> Abstracts some link-layer details.</p>
        </div>
      </div>

      <figure>
        <img src="../assets/docker-compose-dns-web.svg" alt="High-level docker-compose style diagram showing three services: r1 (router+dns), h1 (client), w1 (web) attached to two bridge networks: netA 10.10.10.0/24 and netB 10.10.20.0/24">
        <figcaption>
          Containerized path: two bridges (<code>netA</code> and <code>netB</code>). R1 connects to both; H1 to <code>netA</code>; W1 to <code>netB</code>. R1 forwards and runs DNS.
        </figcaption>
      </figure>

      <details>
        <summary>Example docker-compose.yml (conceptual)</summary>
        <pre data-lang="yaml"><code>
version: "3.9"
networks:
  netA: { ipam: { config: [ { subnet: 10.10.10.0/24 } ] } }
  netB: { ipam: { config: [ { subnet: 10.10.20.0/24 } ] } }

services:
  r1:
    image: ghcr.io/demo/router-dns:latest
    networks:
      netA: { ipv4_address: 10.10.10.1 }
      netB: { ipv4_address: 10.10.20.1 }
    cap_add: [ "NET_ADMIN" ]
    command: ["/bin/sh","-c","sysctl -w net.ipv4.ip_forward=1; dnsmasq -k"]

  h1:
    image: ghcr.io/demo/devshell:latest
    networks: { netA: { ipv4_address: 10.10.10.100 } }
    dns: [10.10.10.1]

  w1:
    image: nginx:alpine
    networks: { netB: { ipv4_address: 10.10.20.100 } }
    dns: [10.10.10.1]
        </code></pre>
      </details>
    </section>

    <!-- DNS & Web -->
    <section class="section">
      <h2 id="dns-web">3) DNS &amp; Web Server Setup</h2>
      <h3>DNS forwarder/authority (R1)</h3>
      <p>
        Configure <strong>dnsmasq</strong> (or similar) as a <em>forwarder</em> for public names and as an <em>authoritative</em> source for <code>web.local</code>. This gives you realistic caching and a local zone you fully control.
      </p>
      <pre data-lang="conf"><code>
# /etc/dnsmasq.d/lab.conf
domain-needed
bogus-priv
no-resolv
server=1.1.1.1
address=/web.local/10.10.20.100
      </code></pre>

      <h3>Web server (W1)</h3>
      <p>
        Start <strong>nginx</strong> (or any simple HTTP server) with an index and a JSON endpoint:
      </p>
      <pre data-lang="bash"><code>
echo '&lt;h1&gt;Hello, Mini Network&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
echo '{ "status": "ok", "service": "w1" }' &gt; /usr/share/nginx/html/health.json
      </code></pre>

      <h3>Client checks (H1)</h3>
      <pre data-lang="cli"><code>
# Name resolution:
dig +short web.local
# Reachability:
ping -c 2 web.local
# HTTP:
curl -v http://web.local/health.json
      </code></pre>

      <figure>
        <img src="../assets/dns-web-stack.svg" alt="Stack diagram showing H1 issuing a DNS query to R1, R1 forwarding or answering locally, and H1 establishing TCP to W1 for HTTP">
        <figcaption>
          Resolution &amp; request flow: H1 asks R1 for <code>web.local</code>; R1 answers from local zone or forwards upstream; H1 connects to W1 via R1 using TCP to fetch content.
        </figcaption>
      </figure>
    </section>

    <!-- Break & Fix Lab -->
    <section class="section">
      <h2 id="break-fix">4) Break &amp; Fix: Guided Debugging Scenarios</h2>
      <p>
        Now we’ll inject faults and fix them using the <strong>6-step workflow</strong> you learned in Chapter 6.
      </p>

      <h3>Scenario A — Wrong default gateway on H1</h3>
      <p><em>Symptom:</em> <code>curl web.local</code> times out; <code>ping 10.10.10.1</code> works.</p>
      <ol>
        <li><strong>Link:</strong> <code>ip -s link</code> shows clean counters.</li>
        <li><strong>DNS:</strong> <code>dig +short web.local</code> → <code>10.10.20.100</code>.</li>
        <li><strong>Reachability:</strong> <code>ping 10.10.20.100</code> fails; <code>traceroute</code> stalls at hop 1.</li>
        <li><strong>Routes:</strong> <code>ip route</code> shows <code>default via 10.10.10.254</code> (wrong). Fix: <code>ip route replace default via 10.10.10.1</code>.</li>
        <li><strong>Verify:</strong> <code>curl -v http://web.local</code> now succeeds.</li>
      </ol>

      <h3>Scenario B — DNS entry missing</h3>
      <p><em>Symptom:</em> <code>curl http://web.local</code> → “could not resolve host”.</p>
      <ol>
        <li><strong>DNS:</strong> <code>dig web.local @10.10.10.1</code> returns <em>NXDOMAIN</em>.</li>
        <li><strong>Fix:</strong> Add <code>address=/web.local/10.10.20.100</code> to dnsmasq; restart.</li>
        <li><strong>Verify:</strong> <code>dig +short web.local</code> returns the IP; HTTP works.</li>
      </ol>

      <h3>Scenario C — MTU/Path issue for large payloads</h3>
      <p><em>Symptom:</em> Small GETs succeed; large uploads hang.</p>
      <ol>
        <li><strong>Hypothesis:</strong> <abbr title="Maximum Transmission Unit">MTU</abbr> mismatch or black-holed <abbr title="Path MTU Discovery">PMTUD</abbr>.</li>
        <li><strong>Test:</strong> <code>ping -M do -s 1472 web.local</code> fails; <code>-s 1400</code> works.</li>
        <li><strong>Fix:</strong> Clamp MSS on R1 or reduce <abbr title="Maximum Segment Size negotiated in TCP options">MSS</abbr> for the path.</li>
      </ol>

      <h3>Scenario D — TLS trust problem</h3>
      <p><em>Symptom:</em> <code>curl https://web.local</code> fails with “certificate verify failed”.</p>
      <ol>
        <li><strong>Check:</strong> <code>openssl s_client -connect web.local:443 -servername web.local</code> shows self-signed cert.</li>
        <li><strong>Options:</strong> For lab use, trust a local root CA or test with <code>curl -k</code> (not for production).</li>
      </ol>
    </section>

    <!-- Case Study -->
    <section class="section">
      <h2 id="case-study">5) Case Study (~200 words): The vanishing API</h2>
      <div class="card">
        <p>
          A team noticed sporadic “connection reset by peer” errors when calling a private API through an on-prem gateway. Pings were fine, and <code>curl -I</code> sometimes succeeded. Packet captures showed TCP handshakes completing, but after the first HTTP request, the server sent an immediate <abbr title="TCP Reset">RST</abbr>.
        </p>
        <p>
          The root cause turned out to be a <strong>split-horizon DNS</strong> discrepancy. Off VPN, the hostname resolved to a cloud endpoint that spoke HTTP/2 over <abbr title="Quick UDP Internet Connections">QUIC</abbr> via a managed edge; on VPN, the same name resolved to an internal IP where a legacy proxy only understood HTTP/1.1 with strict header size limits. When clients negotiated HTTP/2 and sent a larger header block, the proxy dropped the connection without a helpful error.
        </p>
        <p>
          The fix was twofold: pin the internal DNS name to a path that enforced HTTP/1.1 and add monitoring for <em>both</em> DNS views. The lesson reinforced the layered approach: Application-level protocol negotiation can fail even when Transport looks clean, and DNS context often explains “works here, fails there.”
        </p>
      </div>
    </section>

    <!-- Examples -->
    <section class="section">
      <h2 id="examples">6) Two Concrete Examples</h2>

      <h3>Example A — NAT hairpinning surprise</h3>
      <p>
        H1 resolves <code>web.local</code> to a <em>public</em> IP that hairpins through R1’s <abbr title="Network Address Translation">NAT</abbr>. Requests time out because R1 doesn’t support hairpin NAT. Fix by returning the <em>internal</em> IP for local clients or enabling hairpin mode.
      </p>

      <h3>Example B — Misleading ping</h3>
      <p>
        <code>ping web.local</code> fails (ICMP blocked), but <code>curl http://web.local</code> works. Don’t over-index on ICMP; test the <strong>actual</strong> Transport/Application path (TCP 80/443).
      </p>
    </section>

    <!-- Practice -->
    <section class="section practice">
      <div class="title">Practice <span class="badge">~40–55 min</span></div>
      <ol>
        <li>
          <strong>Bring-up log (10–12 min).</strong> Stand up R1, H1, W1 (Path A or B). Record IPs, <abbr title="Default route used when no longer-specific route matches">default route</abbr>, and DNS config. <em>Success:</em> You can resolve <code>web.local</code> and fetch <code>/health.json</code>.
        </li>
        <li>
          <strong>Break &amp; fix (12–15 min).</strong> Intentionally set the wrong gateway on H1; capture the failure with <code>traceroute</code> and <code>ip route get</code>; fix it. <em>Success:</em> Before/after evidence and a one-paragraph root cause.
        </li>
        <li>
          <strong>MTU probe (10–12 min).</strong> Find your max <code>ping -M do -s N</code>. <em>Success:</em> You document a working size and relate it to any tunnels or bridges in your setup.
        </li>
        <li>
          <strong>Optional TLS (6–10 min).</strong> Add self-signed TLS to W1 and test with <code>openssl s_client</code>. <em>Success:</em> You identify SNI and certificate chain behavior.
        </li>
      </ol>
    </section>

    <!-- Mastery -->
    <section class="section mastery">
      <div class="title">Mastery Check <span class="badge">Self-review</span></div>

      <details>
        <summary>1) In one sentence, explain why H1 can’t reach W1 if H1’s default gateway is wrong.</summary>
        <p><strong>Answer:</strong> Off-subnet traffic needs a next hop; with a wrong gateway, H1 sends frames to a non-existent or incorrect MAC, so packets never leave the subnet.</p>
      </details>

      <details>
        <summary>2) What does a local DNS forwarder buy you over hardcoding /etc/hosts?</summary>
        <p><strong>Answer:</strong> Centralized management, caching, and realistic behavior (TTL, upstream failures) that mirrors production more closely than static host files.</p>
      </details>

      <details>
        <summary>3) How would you detect a split-horizon DNS issue?</summary>
        <p><strong>Answer:</strong> Query the same name from both sides of the boundary (e.g., on/off VPN) and compare answers; use <code>dig @resolver</code> to target specific resolvers; test with <code>curl --resolve</code> to pin an IP.</p>
      </details>

      <details>
        <summary>4) Why can HTTP work while ping fails?</summary>
        <p><strong>Answer:</strong> ICMP is often filtered; TCP 80/443 may be allowed. Different protocols/policies apply at firewalls.</p>
      </details>

      <details>
        <summary>5) Give two ways to prove an MTU/PMTUD problem.</summary>
        <p><strong>Answer:</strong> (1) <code>ping -M do -s N</code> binary search for max size; (2) packet capture showing repeated <abbr title="Internet Control Message Protocol">ICMP</abbr> “fragmentation needed” or TCP retransmissions on large payloads only.</p>
      </details>

      <details>
        <summary>6) Contrast static IPs vs DHCP reservations for this lab.</summary>
        <p><strong>Answer:</strong> Static IPs are simple and deterministic but manual to change; DHCP reservations centralize management and scale better, at the cost of extra moving parts and lease state.</p>
      </details>

      <details>
        <summary>7) Where would you look if HTTPS to web.local fails only on VPN?</summary>
        <p><strong>Answer:</strong> Routes (<code>ip route</code>) for new prefixes, DNS answers on-VPN vs off-VPN, and trust roots (corporate CA); packet capture to see if TLS fails before ServerHello.</p>
      </details>
    </section>

    <!-- Resources -->
    <section class="section" id="resources">
      <h2>Resources</h2>
      <div class="resource-list">
        <div class="item">
          <div>
            <a class="external" href="https://www.wireshark.org/docs/" target="_blank">Wireshark User’s Guide</a>
            <div class="meta">Filters, protocol dissection, and practical capture strategies.</div>
          </div>
          <span class="badge">Docs</span>
        </div>
        <div class="item">
          <div>
            <a class="external" href="https://docs.docker.com/network/" target="_blank">Docker Networking</a>
            <div class="meta">How bridge networks, port publishing, and DNS work in containers.</div>
          </div>
          <span class="badge">Guide</span>
        </div>
        <div class="item">
          <div>
            <a class="external" href="https://thekelleys.org.uk/dnsmasq/doc.html" target="_blank">dnsmasq Documentation</a>
            <div class="meta">Small-footprint DNS and DHCP suitable for lab environments.</div>
          </div>
          <span class="badge">Docs</span>
        </div>
      </div>
    </section>

    <!-- Recap & Next -->
    <section class="section">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p>
        You planned a topology, configured addressing and a gateway, ran local DNS and HTTP, and exercised a structured debugging workflow by breaking and fixing realistic issues (gateway, DNS, MTU, TLS). You now have a pocket lab you can reuse when learning new protocols or reproducing production incidents.
      </p>
      <p>
        In <a href="chapters/ch08.html">Chapter 8</a>, you’ll distill the most common pitfalls, adopt lightweight best practices, and choose next steps toward intermediate networking skills.
      </p>
    </section>

    <nav class="next-prev">
      <a href="chapters/ch06.html" rel="prev">Previous: Networking Tools &amp; Workflows for Developers</a>
      <a href="chapters/ch08.html" rel="next">Next: Pitfalls, Best Practices &amp; Next Steps</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="muted">© 2025 BookBuilder Project.</p>
    </div>
  </footer>

  <!--
  CHECKLIST
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for chapter page)
  - [x] <base> present & correct (../)
  - [x] Canonical nav verbatim; active link set to "Chapters"
  - [x] Pager prev/next valid (ch06 ↔ ch08)
  - [x] Sections meet Depth minima (1,200–1,800 words; ≥2 examples; 1 case study; 1 compare/contrast; 1 analogy; explicit trade-off)
  - [x] Practice 3–5 tasks with time & success criteria
  - [x] Mastery 5–7 Qs with answers in <details>
  - [x] ≥10 glossary terms via <abbr> (gateway, resolver, DHCP, VLAN, bridge, ARP, PMTUD, MTU, MSS, QUIC, NAT, CA, SNI)
  - [x] ≥1 figure (../assets/mini-network-topology.svg) + additional figures (docker-compose-dns-web.svg, dns-web-stack.svg)
  -->
</body>
</html>




